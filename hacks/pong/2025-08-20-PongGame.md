---
layout: post
title: üèì Complete Pong Game Code Implementation
description: Complete HTML, CSS, and JavaScript code for building a fully functional 2-player Pong game
categories: ['Game Development', 'JavaScript', 'Canvas API', 'Code Implementation']
permalink: /custompong
menu: nav/tools_setup.html
toc: True
comments: True
---

## üéÆ Pong Game Demo

<div class="game-canvas-container" style="text-align:center;">
  <canvas id="pongCanvas" width="800" height="500"></canvas>
  <br>
  <button id="restartBtn">Restart Game</button>

  <!-- SpeedBoostMode controls -->
  <div id="controls" style="margin-top:12px;">
    <label style="color:#fff; user-select:none;">
      <input type="checkbox" id="boostToggle"> Speed Boost Mode
    </label>
    <span id="boostStatus" style="color:#fff; margin-left:12px;">x1.00</span>
  </div>
</div>

<style>
  .game-canvas-container { margin-top: 20px; }
  #pongCanvas { border: 2px solid #fff; background: #000; }
  #restartBtn {
    display: none; margin-top: 15px; padding: 10px 20px; font-size: 18px;
    border: none; border-radius: 6px; background: #4caf50; color: white; cursor: pointer;
  }
  #restartBtn:hover { background: #45a049; }

  /* SpeedBoostMode controls */
  #controls { display: inline-flex; align-items: center; gap: 12px; }
  #controls input { transform: scale(1.2); cursor: pointer; }
  #controls label { cursor: pointer; }
</style>

<script>
/* =============== DOM refs =============== */
const canvas = document.getElementById('pongCanvas');
const ctx = canvas.getContext('2d');
const restartBtn = document.getElementById('restartBtn');

const boostToggle = document.getElementById('boostToggle');
const boostStatus = document.getElementById('boostStatus');

/* =============== Classes =============== */
class Paddle {
  constructor(x, y, w, h, speed, upKey, downKey) {
    this.x = x; this.y = y;
    this.w = w; this.h = h;
    this.speed = speed;
    this.upKey = upKey; this.downKey = downKey;
    this.color = "#fff";
  }
  move(keys, canvasH) {
    if (keys[this.upKey]) this.y -= this.speed;
    if (keys[this.downKey]) this.y += this.speed;
    if (this.y < 0) this.y = 0;
    if (this.y + this.h > canvasH) this.y = canvasH - this.h;
  }
  draw(ctx) { ctx.fillStyle = this.color; ctx.fillRect(this.x, this.y, this.w, this.h); }
  center(canvasH) { this.y = (canvasH - this.h) / 2; }
}

class Ball {
  constructor(r) {
    this.r = r;
    this.x = 0; this.y = 0;
    this.vx = 0; this.vy = 0;
    this.color = "#fff";
  }
  reset(W, H) {
    this.x = W/2; this.y = H/2;
    this.vx = Math.random() > 0.5 ? 5 : -5;
    this.vy = (Math.random() * 4) - 2;
    this.color = Ball.randomColor();
  }
  move() { this.x += this.vx; this.y += this.vy; }
  wallBounce(H) { if (this.y + this.r > H || this.y - this.r < 0) this.vy = -this.vy; }
  speed() { return Math.hypot(this.vx, this.vy); }
  clamp(max) { const s = this.speed(); if (s > max) { const k = max / s; this.vx *= k; this.vy *= k; } }
  enforceMinX(min) {
    if (Math.abs(this.vx) < min) {
      const dir = this.vx === 0 ? (Math.random() < 0.5 ? -1 : 1) : Math.sign(this.vx);
      this.vx = dir * min;
    }
  }
  draw(ctx) { ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(this.x, this.y, this.r, 0, Math.PI*2); ctx.fill(); }
  static randomColor() { const L="0123456789ABCDEF"; let c="#"; for (let i=0;i<6;i++) c+=L[Math.floor(Math.random()*16)]; return c; }
}

/* =============== Game (OOP + persistence) =============== */
class Game {
  constructor(canvas, ctx) {
    this.canvas = canvas; this.ctx = ctx;
    this.W = canvas.width; this.H = canvas.height;

    // gameplay constants
    this.pW = 8; this.pH = 80; this.paddleSpeed = 7;
    this.ballR = 10;
    this.winningScore = 10;
    this.gameOver = false;

    // speed boost constants
    this.HITS_PER_BOOST = 3;
    this.BOOST_FACTOR = 1.10;
    this.MAX_SPEED = 18;
    this.MIN_X_SPEED = 2.0; // anti "yo-yo"

    // state
    this.p1 = new Paddle(0, (this.H - this.pH)/2, this.pW, this.pH, this.paddleSpeed, "w", "s");
    this.p2 = new Paddle(this.W - this.pW, (this.H - this.pH)/2, this.pW, this.pH, this.paddleSpeed, "i", "k");
    this.ball = new Ball(this.ballR);
    this.player1Score = 0; this.player2Score = 0;

    // SpeedBoost tracking UI state
    this.hitCount = 0;
    this.speedMultiplier = 1;
    this.boostFlashFrames = 0; this.boostFlashX = 0; this.boostFlashY = 0;

    // Load settings BEFORE first serve (persistence moved into Game)
    this.loadSettings();
    boostToggle.addEventListener('change', () => { this.saveSettings(); this.updateBoostUI(); });

    // first serve
    this.serve();
  }

  /* ---------- Persistence (localStorage) ---------- */
  loadSettings() {
    try {
      const raw = localStorage.getItem('pong.settings');
      if (!raw) return;
      const cfg = JSON.parse(raw);
      if (typeof cfg.boostEnabled !== "undefined") boostToggle.checked = !!cfg.boostEnabled;
      // Example for future: if (cfg.winningScore) this.winningScore = cfg.winningScore;
    } catch(_) { /* ignore bad JSON */ }
    this.updateBoostUI();
  }
  saveSettings() {
    const cfg = {
      boostEnabled: !!boostToggle.checked,
      // winningScore: this.winningScore, // add when you expose a UI to change it
    };
    localStorage.setItem('pong.settings', JSON.stringify(cfg));
  }

  /* ---------- Core flow ---------- */
  serve() {
    this.ball.reset(this.W, this.H);
    this.ball.enforceMinX(this.MIN_X_SPEED);
    if (boostToggle.checked) this.resetBoost();
    this.boostFlashFrames = 0;
  }

  applyBoostIfNeeded() {
    if (boostToggle.checked && this.hitCount > 0 && this.hitCount % this.HITS_PER_BOOST === 0) {
      this.ball.vx *= this.BOOST_FACTOR; this.ball.vy *= this.BOOST_FACTOR;
      this.speedMultiplier *= this.BOOST_FACTOR;
      this.ball.clamp(this.MAX_SPEED);
      this.ball.enforceMinX(this.MIN_X_SPEED);
      this.updateBoostUI();
      // start flash near ball
      this.boostFlashFrames = 30;
      this.boostFlashX = this.ball.x; this.boostFlashY = this.ball.y;
    }
  }

  resetBoost() { this.hitCount = 0; this.speedMultiplier = 1; this.updateBoostUI(); }
  updateBoostUI() { boostStatus.textContent = "x" + this.speedMultiplier.toFixed(2); }

  update(keys) {
    if (this.gameOver) return;

    // input
    this.p1.move(keys, this.H);
    this.p2.move(keys, this.H);

    // physics
    this.ball.move();
    this.ball.wallBounce(this.H);

    // collisions: left paddle (tamer deflection gain)
    if (this.ball.x - this.ball.r < this.p1.x + this.p1.w &&
        this.ball.y > this.p1.y && this.ball.y < this.p1.y + this.p1.h) {
      this.ball.vx = -this.ball.vx;
      const d = this.ball.y - (this.p1.y + this.p1.h/2);
      this.ball.vy = d * 0.2;  // left: 0.2
      this.ball.color = Ball.randomColor();
      this.ball.vx *= 1.02;    // tiny nudge to avoid perfectly vertical loops
      this.hitCount++; this.applyBoostIfNeeded(); this.ball.enforceMinX(this.MIN_X_SPEED);
    }

    // collisions: right paddle
    if (this.ball.x + this.ball.r > this.p2.x &&
        this.ball.y > this.p2.y && this.ball.y < this.p2.y + this.p2.h) {
      this.ball.vx = -this.ball.vx;
      const d = this.ball.y - (this.p2.y + this.p2.h/2);
      this.ball.vy = d * 0.3;  // right: 0.3
      this.ball.color = Ball.randomColor();
      this.ball.vx *= 1.02;
      this.hitCount++; this.applyBoostIfNeeded(); this.ball.enforceMinX(this.MIN_X_SPEED);
    }

    // scoring
    if (this.ball.x - this.ball.r < 0) {
      this.player2Score++;
      if (this.player2Score >= this.winningScore) { this.gameOver = true; restartBtn.style.display = "inline-block"; }
      this.serve();
    } else if (this.ball.x + this.ball.r > this.W) {
      this.player1Score++;
      if (this.player1Score >= this.winningScore) { this.gameOver = true; restartBtn.style.display = "inline-block"; }
      this.serve();
    }
  }

  draw() {
    const ctx = this.ctx;
    // background
    ctx.fillStyle = "#000";
    ctx.fillRect(0, 0, this.W, this.H);

    // paddles & ball
    this.p1.draw(ctx); this.p2.draw(ctx); this.ball.draw(ctx);

    // scores
    ctx.fillStyle = "white"; ctx.font = "30px Arial";
    ctx.fillText(this.player1Score, this.W/4, 50);
    ctx.fillText(this.player2Score, 3*this.W/4, 50);

    // game over text
    if (this.gameOver) {
      ctx.fillStyle = "red";   ctx.fillText("Game Over", this.W/2 - 80, this.H/2 - 20);
      ctx.fillStyle = "yellow";ctx.fillText(this.player1Score >= this.winningScore ? "Player 1 Wins!" : "Player 2 Wins!", this.W/2 - 120, this.H/2 + 20);
    }

    // boost flash
    if (this.boostFlashFrames > 0) {
      const a = this.boostFlashFrames / 30;
      ctx.save(); ctx.globalAlpha = a; ctx.fillStyle = "cyan"; ctx.font = "20px Arial";
      ctx.fillText("+10%", this.boostFlashX - 16, this.boostFlashY - 16 - (30 - this.boostFlashFrames) * 0.5);
      ctx.restore();
      this.boostFlashFrames--;
    }
  }

  restart() {
    this.player1Score = 0; this.player2Score = 0;
    this.p1.center(this.H); this.p2.center(this.H);
    this.gameOver = false; restartBtn.style.display = "none";
    this.serve();
  }
}

/* =============== Input & Boot =============== */
const keys = {};
document.addEventListener("keydown", e => keys[e.key] = true);
document.addEventListener("keyup",   e => keys[e.key] = false);

const game = new Game(canvas, ctx);  // loads settings inside the constructor

restartBtn.addEventListener("click", () => game.restart());

function loop(){ game.update(keys); game.draw(); requestAnimationFrame(loop); }
loop();
</script>




